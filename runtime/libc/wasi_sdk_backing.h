#pragma once
#include <stdint.h>

/**
 * Based on C header generated from wasi_snapshot_preview1.witx
 * See https://github.com/WebAssembly/wasi-libc/blob/main/libc-bottom-half/headers/public/wasi/api.h 
 */

typedef uint8_t wasi_advice_t;

typedef uint32_t wasi_clockid_t;

/**
 * Identifier for a device containing a file system. Can be used in combination
 * with `inode` to uniquely identify a file or directory in the filesystem.
 */
typedef uint64_t wasi_device_t;

/**
 * A reference to the offset of a directory entry.
 * The value 0 signifies the start of the directory.
 */
typedef uint64_t wasi_dircookie_t;

typedef uint16_t wasi_errno_t;

/* The state of the file descriptor subscribed to with fd_read or fd_write */
typedef uint16_t wasi_eventrwflags_t;

/* Type of a subscription to an event or its occurrence */
typedef uint8_t wasi_eventtype_t;

/* Exit code generated by a process when exiting */
typedef uint32_t wasi_exitcode_t;

typedef int wasi_fd_t;

/* File descriptor flags */
typedef uint16_t wasi_fdflags_t;

/* Relative offset within a file */
typedef int64_t wasi_filedelta_t;

typedef uint64_t wasi_filesize_t;

/* The type of a file descriptor or file */
typedef uint8_t wasi_filetype_t;

/* File time attributes */
typedef uint16_t wasi_fstflags_t;

/* File serial number that is unique within its file system */
typedef uint64_t wasi_inode_t;

/* Number of hard links to an inode */
typedef uint64_t wasi_linkcount_t;

/* Flags determining the method of how paths are resolved */
typedef uint32_t wasi_lookupflags_t;

/* Open flags used by `path_open` */
typedef uint16_t wasi_oflags_t;

/* Flags provided to `sock_recv` */
typedef uint16_t wasi_riflags_t;

/* Flags returned by `sock_recv` */
typedef uint16_t wasi_roflags_t;

/* File descriptor rights, determining which actions may be performed. */
typedef uint64_t wasi_rights_t;

/* Which channels on a socket to shut down */
typedef uint8_t wasi_sdflags_t;

/**
 * Flags provided to `sock_send`. As there are currently no flags
 * defined, it must be set to zero.
 */
typedef uint16_t wasi_siflags_t;

/* Signal condition */
typedef uint8_t wasi_signal_t;

/* Explicitly assuming 32-bit WebAssembly */
typedef uint32_t wasi_size_t;

/**
 * Flags determining how to interpret the timestamp provided in
 * `subscription_clock::timeout`.
 */
typedef uint16_t wasi_subclockflags_t;

typedef uint64_t wasi_timestamp_t;

/**
 * User-provided value that may be attached to objects that is retained when
 * extracted from the implementation.
 */
typedef uint64_t wasi_userdata_t;

/* The position relative to which to set the offset of the file descriptor */
typedef uint8_t wasi_whence_t;

enum wasi_errnos {
    WASI_ESUCCESS           = 0,
    WASI_E2BIG              = 1,
    WASI_EACCES             = 2,
    WASI_EADDRINUSE         = 3,
    WASI_EADDRNOTAVAIL      = 4,
    WASI_EAFNOSUPPORT       = 5,
    WASI_EAGAIN             = 6,
    WASI_EALREADY           = 7,
    WASI_EBADF              = 8,
    WASI_EBADMSG            = 9,
    WASI_EBUSY              = 10,
    WASI_ECANCELED          = 11,
    WASI_ECHILD             = 12,
    WASI_ECONNABORTED       = 13,
    WASI_ECONNREFUSED       = 14,
    WASI_ECONNRESET         = 15,
    WASI_EDEADLK            = 16,
    WASI_EDESTADDRREQ       = 17,
    WASI_EDOM               = 18,
    WASI_EDQUOT             = 19,
    WASI_EEXIST             = 20,
    WASI_EFAULT             = 21,
    WASI_EFBIG              = 22,
    WASI_EHOSTUNREACH       = 23,
    WASI_EIDRM              = 24,
    WASI_EILSEQ             = 25,
    WASI_EINPROGRESS        = 26,
    WASI_EINTR              = 27,
    WASI_EINVAL             = 28,
    WASI_EIO                = 29,
    WASI_EISCONN            = 30,
    WASI_EISDIR             = 31,
    WASI_ELOOP              = 32,
    WASI_EMFILE             = 33,
    WASI_EMLINK             = 34,
    WASI_EMSGSIZE           = 35,
    WASI_EMULTIHOP          = 36,
    WASI_ENAMETOOLONG       = 37,
    WASI_ENETDOWN           = 38,
    WASI_ENETRESET          = 39,
    WASI_ENETUNREACH        = 40,
    WASI_ENFILE             = 41,
    WASI_ENOBUFS            = 42,
    WASI_ENODEV             = 43,
    WASI_ENOENT             = 44,
    WASI_ENOEXEC            = 45,
    WASI_ENOLCK             = 46,
    WASI_ENOLINK            = 47,
    WASI_ENOMEM             = 48,
    WASI_ENOMSG             = 49,
    WASI_ENOPROTOOPT        = 50,
    WASI_ENOSPC             = 51,
    WASI_ENOSYS             = 52,
    WASI_ENOTCONN           = 53,
    WASI_ENOTDIR            = 54,
    WASI_ENOTEMPTY          = 55,
    WASI_ENOTRECOVERABLE    = 56,
    WASI_ENOTSOCK           = 57,
    WASI_ENOTSUP            = 58,
    WASI_ENOTTY             = 59,
    WASI_ENXIO              = 60,
    WASI_EOVERFLOW          = 61,
    WASI_EOWNERDEAD         = 62,
    WASI_EPERM              = 63,
    WASI_EPIPE              = 64,
    WASI_EPROTO             = 65,
    WASI_EPROTONOSUPPORT    = 66,
    WASI_EPROTOTYPE         = 67,
    WASI_ERANGE             = 68,
    WASI_EROFS              = 69,
    WASI_ESPIPE             = 70,
    WASI_ESRCH              = 71,
    WASI_ESTALE             = 72,
    WASI_ETIMEDOUT          = 73,
    WASI_ETXTBSY            = 74,
    WASI_EXDEV              = 75,
    WASI_ENOTCAPABLE        = 76,
};

enum wasi_fdflags {
    WASI_FDFLAG_APPEND      = 0x0001,
    WASI_FDFLAG_DSYNC       = 0x0002,
    WASI_FDFLAG_NONBLOCK    = 0x0004,
    WASI_FDFLAG_RSYNC       = 0x0008,
    WASI_FDFLAG_SYNC        = 0x0010,
};

enum wasi_filetype {
    WASI_FILETYPE_UNKNOWN           = 0,
    WASI_FILETYPE_BLOCK_DEVICE      = 1,
    WASI_FILETYPE_CHARACTER_DEVICE  = 2,
    WASI_FILETYPE_DIRECTORY         = 3,
    WASI_FILETYPE_REGULAR_FILE      = 4,
    WASI_FILETYPE_SOCKET_DGRAM      = 5,
    WASI_FILETYPE_SOCKET_STREAM     = 6,
    WASI_FILETYPE_SYMBOLIC_LINK     = 7,
};

enum wasi_oflags {
    WASI_O_CREAT        = 0x0001,
    WASI_O_DIRECTORY    = 0x0002,
    WASI_O_EXCL         = 0x0004,
    WASI_O_TRUNC        = 0x0008,
};

enum wasi_rights {
    WASI_RIGHT_FD_DATASYNC              = 0x0000000000000001ULL,
    WASI_RIGHT_FD_READ                  = 0x0000000000000002ULL,
    WASI_RIGHT_FD_SEEK                  = 0x0000000000000004ULL,
    WASI_RIGHT_FD_FDSTAT_SET_FLAGS      = 0x0000000000000008ULL,
    WASI_RIGHT_FD_SYNC                  = 0x0000000000000010ULL,
    WASI_RIGHT_FD_TELL                  = 0x0000000000000020ULL,
    WASI_RIGHT_FD_WRITE                 = 0x0000000000000040ULL,
    WASI_RIGHT_FD_ADVISE                = 0x0000000000000080ULL,
    WASI_RIGHT_FD_ALLOCATE              = 0x0000000000000100ULL,
    WASI_RIGHT_PATH_CREATE_DIRECTORY    = 0x0000000000000200ULL,
    WASI_RIGHT_PATH_CREATE_FILE         = 0x0000000000000400ULL,
    WASI_RIGHT_PATH_LINK_SOURCE         = 0x0000000000000800ULL,
    WASI_RIGHT_PATH_LINK_TARGET         = 0x0000000000001000ULL,
    WASI_RIGHT_PATH_OPEN                = 0x0000000000002000ULL,
    WASI_RIGHT_FD_READDIR               = 0x0000000000004000ULL,
    WASI_RIGHT_PATH_READLINK            = 0x0000000000008000ULL,
    WASI_RIGHT_PATH_RENAME_SOURCE       = 0x0000000000010000ULL,
    WASI_RIGHT_PATH_RENAME_TARGET       = 0x0000000000020000ULL,
    WASI_RIGHT_PATH_FILESTAT_GET        = 0x0000000000040000ULL,
    WASI_RIGHT_PATH_FILESTAT_SET_SIZE   = 0x0000000000080000ULL,
    WASI_RIGHT_PATH_FILESTAT_SET_TIMES  = 0x0000000000100000ULL,
    WASI_RIGHT_FD_FILESTAT_GET          = 0x0000000000200000ULL,
    WASI_RIGHT_FD_FILESTAT_SET_SIZE     = 0x0000000000400000ULL,
    WASI_RIGHT_FD_FILESTAT_SET_TIMES    = 0x0000000000800000ULL,
    WASI_RIGHT_PATH_SYMLINK             = 0x0000000001000000ULL,
    WASI_RIGHT_PATH_REMOVE_DIRECTORY    = 0x0000000002000000ULL,
    WASI_RIGHT_PATH_UNLINK_FILE         = 0x0000000004000000ULL,
    WASI_RIGHT_POLL_FD_READWRITE        = 0x0000000008000000ULL,
    WASI_RIGHT_SOCK_SHUTDOWN            = 0x0000000010000000ULL,
};

/**
 * The contents of an `event` when type is `eventtype::fd_read` or
 * `eventtype::fd_write`.
 */
typedef struct wasi_event_fd_readwrite_t
{
    wasi_filesize_t nbytes;    /* bytes available for reading or writing */
    wasi_eventrwflags_t flags; /* The state of the file descriptor */
} wasi_event_fd_readwrite_t;

/**
 * An event that occurred.
 */
typedef struct wasi_event_t
{
    wasi_userdata_t userdata; /* User-provided value */
    wasi_errno_t error;       /* If non-zero, an error while processing the subscription request */
    wasi_eventtype_t type;    /* The type of event that occurred */
    /**
     * The contents of the event, if it is an `eventtype::fd_read` or
     * `eventtype::fd_write`. `eventtype::clock` events ignore this field.
     */
    wasi_event_fd_readwrite_t fd_readwrite;
} wasi_event_t;


struct wasi_fdstat
{
    wasi_filetype_t fs_filetype;
    wasi_fdflags_t fs_flags;
    wasi_rights_t fs_rights_base;
    wasi_rights_t fs_rights_inheriting;
};

/* File attributes */
typedef struct wasi_filestat_t
{
    wasi_device_t dev;        /* Device ID of device containing the file */
    wasi_inode_t ino;         /* File serial number */
    wasi_filetype_t filetype; /* File type */
    wasi_linkcount_t nlink;   /* Number of hard links to the file */
    /* For regular files, the file size in bytes. 
     * For symbolic links, the length in bytes of the pathname contained in the symbolic link.
     */
    wasi_filesize_t size;
    wasi_timestamp_t atim; /* Last data access timestamp */
    wasi_timestamp_t mtim; /* Last data modification timestamp */
    wasi_timestamp_t ctim; /* Last file status change timestamp */

} wasi_filestat_t;

struct wasi_iovec
{
    wasi_size_t base_offset;
    wasi_size_t len;
};

/**
 * The contents of a `subscription` when type is `eventtype::clock`.
 */
typedef struct wasi_subscription_clock_t {
    
    wasi_clockid_t id; /* The clock against which to compare the timestamp */
    wasi_timestamp_t timeout; /* The absolute or relative timestamp */
    /**
     * The amount of time that the implementation may wait additionally
     * to coalesce with other events.
     */
    wasi_timestamp_t precision;

   
    wasi_subclockflags_t flags;  /* absolute or relative */

} wasi_subscription_clock_t;

/**
 * The contents of a `subscription` when type is type is
 * `eventtype::fd_read` or `eventtype::fd_write`.
 */
typedef struct wasi_subscription_fd_readwrite_t {
    /* The file descriptor on which to wait for it to become ready for reading or writing */
    wasi_fd_t file_descriptor;
} wasi_subscription_fd_readwrite_t;

/**
 * The contents of a `subscription`.
 */
typedef union wasi_subscription_u_u_t {
    wasi_subscription_clock_t clock;
    wasi_subscription_fd_readwrite_t fd_read;
    wasi_subscription_fd_readwrite_t fd_write;
} wasi_subscription_u_u_t;


typedef struct __wasi_subscription_u_t {
    uint8_t tag;
    wasi_subscription_u_u_t u;
} wasi_subscription_u_t;

/**
 * Subscription to an event.
 */
typedef struct wasi_subscription_t {
    /**
     * User-provided value that is attached to the subscription in the
     * implementation and returned through `event::userdata`.
     */
    wasi_userdata_t userdata;

    /* The type of the event to which to subscribe, and its contents */
    wasi_subscription_u_t u;

} wasi_subscription_t;